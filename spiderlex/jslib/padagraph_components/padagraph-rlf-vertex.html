<link rel="import" href="../../static/bower_components/polymer/polymer.html"/><link rel="import" href="./padagraph-card-property.html"/><dom-module id="rlf-lexfunc-filter"><style>.menu .form {padding:6px}

.ui.typefilter.checkbox {
    margin-left: 12px;
}
.ui.groupfilter.checkbox {
    margin-top: 12px;
}
</style><template><div class="ui vertical menu">       <template is="dom-if" if="{{ filter_visible(filters, 'all') }}"> <div on-click="reset_filters" class="link item">All</div></template><template is="dom-if" if="[[ filter_visible(filters,'selected') ]]"> <div on-click="set_selected_label" class="item"><padagraph-vertex-card-xs model="[[selected_node]]"></padagraph-vertex-card-xs></div><div class="divider"></div></template><template is="dom-if" if="{{ filter_visible(filters,'label') }}"> <template is="dom-if" if="{{ filter_visible(filters,'headers') }}"> <h4 class="ui header">Label</h4></template><div class="ui form"><div style="margin: 0 1em 0.3em 0em;" class="field"><div class="ui small icon input"><i class="search icon"></i><input type="text" placeholder="Label filter" value="{{filter_label::input}}"/></div></div><template is="dom-if" if="{{is_mode_node}}"> <div class="field"><div class="ui labelfilter checkbox"><input type="checkbox" on-click="click_filter_label_chk"/><label>include neighbors</label></div></div></template></div><div class="divider"></div></template><template is="dom-if" if="{{ filter_visible(filters,'types') }}"> <template is="dom-if" if="{{ filter_visible('headers') }}"><h4 class="ui header">Types</h4></template><div class="ui form groups"><template is="dom-repeat" items="{{filter_groups}}" as="group"><div class="field"><div class="ui groupfilter checkbox"><input id="chkgroup{{group.label}}" on-click="set_group_filter" type="checkbox" checked="checked"/><label for$="chkgroup{{group.label}}">{{group.label}} ({{group.count}}) </label></div></div><template is="dom-repeat" items="{{group.items}}" as="item"><div class="field"><div class="ui typefilter checkbox"><input id="type{{item.label}}" on-click="set_type_filter" type="checkbox" checked="checked"/><label for$="type{{item.label}}"><rlf-edge-type model="{{item.model}}"></rlf-edge-type><div class="ui tiny basic label">{{item.count}}</div></label></div></div></template></template></div><div class="divider"></div></template><template is="dom-if" if="{{ filter_visible(filters,'headers') }}"> <h4 class="ui header">Layout</h4></template><template is="dom-if" if="{{ filter_visible(filters,'layout') }}"> <div class="form"><div class="field"><div on-click="update_layout" class="ui primary compact button">update</div></div></div></template></div></template><script>'use strict';

require(['backbone', 'jquery', 'semantic'], function (Backbone, $, S) {

    Polymer({
        is: "rlf-lexfunc-filter",

        properties: {
            app: Object,
            graph: Object,
            mode: {
                type: String, value: 'node' }, // [edge, node]

            asitem: { type: Boolean, value: false },
            aslabel: { type: Boolean, value: false },

            //- autocompute layout
            autocompute: { type: Boolean, value: false },

            /* privates */
            elements: {
                type: Array, value: function value() {
                    return [];
                } },

            filters: String,

            filter_groups: {
                type: Array, value: null },
            filter_types: {
                type: Array, value: null },
            filter_label: {
                type: String, value: "" },
            filter_label_chk: {
                type: Boolean, value: false },
            filter_reset: {
                type: Boolean, value: false },
            filtered_count: {
                type: String
            },

            groups_sort: Object
        },

        observers: ['setGraphModel(app, graph)', 'apply_filters(elements, filter_groups, filter_label, filter_label_chk, filter_reset)'],

        button_class: function button_class(css, asitem, aslabel) {
            return css + " " + (this.asitem ? "item" : this.aslabel ? "label" : "");
        },

        created: function created() {
            this._listener = {};
            _.extend(this._listener, Backbone.Events);
        },

        setGraphModel: function setGraphModel(app, graph) {

            if (!app || !graph) return;

            $('.dropdown', this).dropdown();
            this.collection = null;
            this.types = null;
            this.is_mode_edge = this.mode == "edge";
            this.is_mode_node = this.mode == "node";

            this.remove_all();

            if (this.is_mode_node) {
                this.collection = this.graph.vs;
                this.types = this.graph.nodetypes;
            } else if (this.is_mode_edge) {
                this.collection = this.graph.es;
                this.types = this.graph.edgetypes;
            }

            this._listener.stopListening();

            this._listener.listenTo(this.collection, 'add', this.push_node.bind(this));
            this._listener.listenTo(this.collection, 'remove', this.pop_node.bind(this));
            this._listener.listenTo(this.collection, 'reset', this.remove_all.bind(this));

            this._listener.listenTo(this.collection, 'addflag:selected', this.add_selected.bind(this));
            this._listener.listenTo(this.collection, 'rmflag:selected', this.rm_selected.bind(this));

            this._listener.listenTo(this.collection, 'filter:changed', this.filter_count.bind(this));
            if (this.is_mode_edge) {
                this._listener.listenTo(this.graph.vs, 'filter:changed', this.filter_count.bind(this));
            }

            //this._listener.listenTo(this.types, 'add', this.reset_filters.bind(this));
            //setTimeout( () => {this.reset_filters()}, 1000 );
        },

        reset_filters: function reset_filters() {

            this.set_type_filters();

            $('.typefilter.checkbox input', this).each(function (e, x) {
                x.checked = true;
            });
            $('.groupfilter.checkbox input', this).each(function (e, x) {
                x.checked = true;
            });
            $('.labelfilter.checkbox input', this).each(function (e, x) {
                x.checked = false;
            });

            _.each(this.filter_groups, function (e, i) {
                e.selected = true;
            });

            _.each(this.filter_types, function (e, i) {
                e.selected = true;
            });

            this.filter_reset = true;
            this.filter_label_chk = false;
            this.filter_label = "";
        },

        filter_visible: function filter_visible(filters, filter) {

            var f = this.filters ? this.filters.split(" ") : [];
            var visible = f.length == 0 || f.indexOf(filter) > -1;
            return visible;
        },

        set_type_filters: function set_type_filters() {
            var types = this.mode == "node" ? this.graph.nodetypes : this.graph.edgetypes;
            var collection = this.mode == "node" ? this.graph.vs : this.graph.es;

            var ls = _.map(types.models, function (e) {
                var filter = function filter(m) {
                    return e.get('uuid') == m.type.get('uuid');
                };
                var count = collection.filter(filter).length;

                var group = e.label.indexOf('/') > 0 ? e.label.substr(0, e.label.indexOf('/')) : "*";
                var name = e.label.substr(e.label.indexOf('/') + 1);

                return { group: group, name: name, label: e.label, selected: true, count: count, model: e };
            });

            var fs = _.filter(ls, function (e) {
                return e.count > 0;
            });

            var groups = _.groupBy(fs, function (e) {
                return e.group;
            });
            groups = _.map(groups, function (v, k) {
                var count = _.reduce(v, function (memo, e) {
                    return memo + e.count;
                }, 0);
                return { label: k, selected: true, items: v, count: count };
            });

            var _v = function _v(e) {
                return e.model.type_attributes ? e.model.type_attributes.order | 0 : 0;
            };
            var groups_sort = function groups_sort(a, b) {
                return _v(a) - _v(b);
            };
            groups.forEach(function (e) {
                e.items.sort(groups_sort);
            });

            this.filter_groups = groups;
        },

        set_group_filter: function set_group_filter(filter) {
            if (filter.model) {
                var group = this;
                filter.model.group.selected = !filter.model.group.selected;
                _.each(filter.model.group.items, function (e) {
                    e.selected = filter.model.group.selected;
                    document.getElementById("type" + e.label).checked = e.selected;
                });

                var array = this.filter_groups;
                this.filter_groups = [];
                this.filter_groups = array;
                this.filter_reset = _.any(filter.model.group.items, function (e) {
                    return !e.selected;
                }) ? false : true;
            } else {
                // match all collection models
                this.reset_filters();
            }
        },

        set_type_filter: function set_type_filter(filter) {
            if (filter && filter.model) {
                var item = filter.model.item;
                item.selected = !item.selected;

                _.each(this.filter_groups, function (e, i) {
                    if (e.label == item.group) {
                        e.selected = true;
                        document.getElementById("chkgroup" + e.label).checked = true;
                    }
                });

                var array = this.filter_groups;
                this.filter_groups = [];
                this.filter_groups = array;
            } else {
                // match all collection models
                this.reset_filters();
            }
        },

        set_selected_label: function set_selected_label() {
            if (this.selected_node) {
                $('.labelfilter.checkbox input', this).each(function (e, x) {
                    x.checked = true;
                });
                $('.groupfilter.checkbox input', this).each(function (e, x) {
                    x.checked = true;
                });
                $('.typefilter.checkbox input', this).each(function (e, x) {
                    x.checked = true;
                });
                this.filter_label_chk = true;
                this.filter_label = this.selected_node.label;
            }
        },

        add_selected: function add_selected(model) {
            this.selected_node = model;
        },

        rm_selected: function rm_selected(model) {
            this.selected_node = null;
        },

        click_filter_label_chk: function click_filter_label_chk() {
            var chk = $('.labelfilter.checkbox input', this)[0];
            this.filter_label_chk = chk.checked;
        },

        update_filtering: function update_filtering() {
            this.apply_filters(this.elements, this.filter_types, this.filter_label, this.filter_label_chk);
        },

        apply_filters: function apply_filters(elements, groups, label, _chk, filter_reset) {
            var _this = this;

            if (!groups || !groups.length) return;

            $(".filter.icon", this).toggleClass('red');
            $(".filter.icon", this).toggleClass('loading');

            _.each(groups, function (g, i) {
                _.each(g.items, function (e, j) {
                    var filter = _this.filtered([{ label: e.label, selected: true }], label);
                    e.count = elements.filter(filter).length;
                    _this.notifyPath('filter_groups.' + i + '.items.' + j + '.count');
                });
                g.count = _.reduce(g.items, function (memo, e) {
                    return memo + e.count;
                }, 0);
                _this.notifyPath('filter_groups.' + i + '.count');
            });

            var graph = this.collection.graph;
            var types = _.flatten(_.map(groups, function (e) {
                return e.items;
            }));
            var filter = this.filtered(types, label);
            var filter_inv = function filter_inv(e) {
                return !filter(e);
            };
            var disabled = this.collection.models.filter(filter_inv);

            if (this.is_mode_node) {

                var vs = this.collection;
                vs.add_flag("disabled", disabled, true);
                vs.trigger('filter:changed');

                var es = this.collection.graph.es;
                var filter_edge = function filter_edge(e) {
                    return e.source.has_flag('disabled') || e.target.has_flag('disabled');
                };

                es.add_flag("disabled-by-nodes", es.models.filter(filter_edge), true, { silent: true });

                disabled = _.union(es.by_flag("disabled-by-edges"), es.by_flag("disabled-by-nodes"));

                es.add_flag("disabled", disabled, true);
                es.trigger("filter:changed");
            } else if (this.is_mode_edge) {

                var es = this.collection;
                es.add_flag("disabled-by-edges", disabled, true, { silent: true });
                var by_nodes = es.by_flag("disabled-by-nodes");

                disabled = _.union(disabled, by_nodes);
                graph.es.add_flag("disabled", disabled, true);
                graph.es.trigger("filter:changed");

                var vs = graph.vs.map(function (v) {
                    var f = function f(e) {
                        return !e.has_flag('disabled');
                    };
                    var edges = graph.incident(v, graph.ALL).filter(f);
                    if (!filter_reset) if (edges.length == 0) return v;
                    return null;
                }).filter(function (v) {
                    return v != null;
                });

                var disabled_by_edges = graph.vs.by_flag("disabled_by_edges");
                disabled = graph.vs.by_flag("disabled");
                disabled = _.chain(disabled).difference(disabled_by_edges).union(vs).value();
                graph.vs.add_flag("disabled_by_edges", vs, true);
                graph.vs.add_flag("disabled", disabled, true);
            }
            $(".filter.icon", this).toggleClass('red');
            $(".filter.icon", this).toggleClass('loading');

            if (this.autocompute) this.update_layout();
        },

        filter_count: function filter_count() {
            var disabled = this.collection.by_flag("disabled");
            this.filtered_count = this.collection.length - disabled.length;
        },

        filtered: function filtered(types, pattern) {
            var mode = this.mode;
            var selected = _.filter(types, function (e) {
                return e.selected;
            });
            var chk_neighbors = this.filter_label_chk;

            return function (item) {

                var matchpattern = true;
                var matchtype = true;

                if (pattern && pattern != "") {
                    var label = item.label.toLowerCase();
                    pattern = pattern.toLowerCase();

                    matchpattern = label.match(pattern);
                    if (mode == "node" && chk_neighbors && !matchpattern && item.neighbors) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = item.neighbors()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var e = _step.value;

                                label = e.label.toLowerCase();
                                matchpattern = label.match(pattern);
                                if (matchpattern) break;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator['return']) {
                                    _iterator['return']();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                }

                matchtype = matchtype & _.filter(selected, function (e) {

                    var label = null;
                    if (mode == "node") label = item.nodetype.label;
                    if (mode == "edge") label = item.edgetype.label;
                    return label == e.label;
                }).length;

                return matchtype && matchpattern;
            };
        },

        update_layout: function update_layout() {
            this.app.trigger('engine:auto_compute');
        },

        push_node: function push_node(el) {

            if (!el) return;
            if (this.mode == "edge" && el.is_loop()) return;

            this.push("elements", el);
        },

        pop_node: function pop_node(el) {
            this.arrayDelete("elements", el);
        },

        remove_all: function remove_all() {
            this.splice("elements", 0, this.elements.length);
        }

    });
});</script></dom-module><dom-module id="rlf-mouse-popup"><style>#pdg-mouse-popup {
   max-width: 600px;
   position: fixed;
   padding: 10px;
   max-height: calc(100% - 24px);
   text-align:center;
   
}
.meta {
   margin: 2 2 8 8px;
 }
.edges a { cursor:pointer; padding:4px }
.intersected.ui.popup {
   max-width: 520px;
   position: relative;
   padding: 1em;
}
.intersected h4 {
   margin: 2 2 8 8px;
}
   </style><template><div id="pdg-mouse-popup" hidden$="{{!is_visible}}"><div class="intersected ui message visible"><template is="dom-if" if="{{ edges }}"><div class="edges"><template is="dom-repeat" items="{{ edges }}" as="edge"><rlf-vertex-xs id="source" graph="{{graph}}" model="[[edge.source]]" over="intersect" clicked="select"></rlf-vertex-xs><a on-click="select" class="edge"><i class="small long right arrow horizontal icon"></i></a><rlf-vertex-xs id="target" graph="{{graph}}" model="[[edge.target]]" over="intersect" clicked="select"> </rlf-vertex-xs><div class="meta"><rlf-edge-type model="{{edge.edgetype}}" family="true"></rlf-edge-type></div><div hidden$="[[computeSpanHidden(index)]]" class="ui divider"></div></template></div></template></div></div></template><script>'use strict';

require(['backbone', 'cello', 'gviz', 'materials', 'pdgconst'], function (Backbone, Cello, Gviz, Materials, Const) {
  Polymer({
    is: "rlf-mouse-popup",

    properties: {
      graph: { type: Object, observer: 'graph_changed' },
      edges: { type: Object, value: null },
      is_visible: {
        type: Boolean,
        computed: 'shouldShow(edges)'
      }
    },

    created: function created() {
      this._listener = {};
      _.extend(this._listener, Backbone.Events);
    },

    graph_changed: function graph_changed() {
      var _this = this;

      this._listener.stopListening();

      this._listener.listenTo(Backbone, 'edge:mouseover', (function (edge, event) {
        if (edge && edge.id) {
          this.edges = edge.graph.es.between(edge.source, edge.target);
          this.setPopupPosition(event);
        }
      }).bind(this));

      this._listener.listenTo(Backbone, 'edge:mouseout', (function (edge, event) {
        this.edges = null;
      }).bind(this));

      this._listener.listenTo(Backbone, 'vertex:mouseover', (function (vertex, event) {
        if (vertex && vertex.id) {
          var src = $(_this).find($(event.srcElement));
          if (!src || src.length == 0) _this.edges = null;
        }
      }).bind(this));
    },

    shouldShow: function shouldShow(edges) {
      return this.edges != null;
    },

    select: function select() {
      Backbone.trigger(Const.select_edge, this.edge);
    },

    get_source_model: function get_source_model(model) {
      if (model) return model.source;
    },
    get_target_model: function get_target_model(model) {
      if (model) return model.target;
    },

    setPopupPosition: function setPopupPosition(event) {
      var nav = navigator.userAgent.toLowerCase();
      var $el = $('#pdg-mouse-popup');
      var $parent = $el.parent();

      var browser = {
        webkit: nav.indexOf("webkit") > 0,
        mozilla: nav.indexOf("firefox") > 0
      };
      var offset = {};
      if (browser.webkit) {
        offset = {
          'top': event.pageY - $el.parent().position().top - $el.height() + 12,
          'left': event.pageX - $el.parent().position().left + 2 };
      } else {
        // if (browser.mozilla){
        var offset = { 'top': event.pageY - $el.parent().position().top - $el.height() + 12,
          'left': event.pageX + 2 };
      }

      console.log(offset);
      $el.offset(offset);
    },

    computed: function computed(obj) {

      if (!obj) return;

      var exclude = { 'label': true, 'image': true };

      var _type = function _type(key) {
        if (model.type && model.type.properties) {
          var t = model.type.properties.get(key);
          if (t && t.otype) return t.otype.type.toLowerCase();
        }
        return "text";
      };
      this.props = Object.keys(obj.properties.attributes).filter(function (e) {
        return !exclude[e];
      }).map(function (e) {
        return {
          "type": _type(e),
          "name": e,
          "value": obj.properties.get(e)
        };
      });
    },

    computeSpanHidden: function computeSpanHidden(index) {
      return this.edges.length - 1 === index;
    }

  });
});</script></dom-module><dom-module id="rlf-edge-type"><style>.family {
    font-weight: bold;
    color: #333;
}

.edgetypelabel {
    margin-left: 1em;
}

.inline {
  display: inline;
}

.cdata {
    margin-right: 1em;
}
</style><template><template is="dom-if" if="{{ family }}">         <div class="edgetypelabel"><span class="family normal-font">{{edgetype.family}} :</span><template is="dom-if" if="{{ !edgetype.cdata }}"><span id="cdata" class="family normal-font"></span><span class="family normal-font">{{edgetype.name}}</span><span class="subscript-font">{{edgetype.subscript}}</span><span class="superscript-font">{{edgetype.superscript}}</span><span class="combination-font">{{edgetype.combination}}</span></template><span class="cdata family normal-font"></span></div></template><template is="dom-if" if="{{ !family }}"><div class="inline"><template is="dom-if" if="{{ !edgetype.cdata }}"><span class="family normal-font">{{edgetype.name}}</span><span class="subscript-font">{{edgetype.subscript}}</span><span class="superscript-font">{{edgetype.superscript}}</span><span class="combination-font">{{edgetype.combination}}</span></template><span class="cdata family normal-font"></span></div></template></template><script>'use strict';

require(['backbone', 'pdgconst'], function (Backbone, Const) {
  Polymer({
    is: "rlf-edge-type",
    properties: {
      model: {
        type: Object
      },
      family: { type: Boolean, value: false }
    },

    observers: ["parse(model)"],

    parse: function parse(model) {
      var _this = this;

      if (!model) return;

      this.edgetype = model.parse_label();
      this.async(function () {
        if (_this.edgetype.cdata) $(".cdata", _this)[0].innerHTML = _this.edgetype.cdata;
        //this.$.cdata.innerHTML = this.edgetype.cdata
      });
    }

  });
});</script></dom-module><dom-module id="rlf-vertex-xs"><style>a { cursor: pointer; }
a.link:hover {text-decoration: underline}
.usagenote {
    font-size: smaller;
    font-weight: bold;
    margin-right: 2px;
    color: black;
}

</style><template><template is="dom-if" if="{{form.length}}"><a title="" on-click="mouseclicked" on-mouseover="mouseover" on-mouseout="mouseout" class="link">{{form}}</a></template><template is="dom-if" if="{{ labelOrItem(vertex, form) }}"><a class$="{{css}}" title="{{vertex.id}}" on-click="mouseclicked" on-mouseover="mouseover" on-mouseout="mouseout"><template is="dom-if" if="{{vertex.icon}}"><i style$="{{vertex.fontcolor}}" class="ui circle icon"></i></template><template is="dom-if" if="{{!vertex.icon}}"><i class="ui small black circle thin icon"></i></template><template is="dom-if" if="{{vertex.usagenote}}"><span class="usagenote">{{vertex.usagenote}}</span></template><template is="dom-if" if="{{vertex.prefix.length}}"><span class="normal-font">{{vertex.prefix}} </span></template><template is="dom-if" if="{{vertex.vocable}}"><span class="normal-font">{{vertex.vocable}}</span></template><template is="dom-if" if="{{vertex.subscript}}"><span class="subscript-font">{{vertex.subscript}}</span></template><template is="dom-if" if="{{vertex.superscript}}"><span class="superscript-font">{{vertex.superscript}}</span></template><template is="dom-if" if="{{vertex.num}}"><span class="num-font">{{vertex.num}}</span></template><!--| {{ model.label}}--></a></template><template is="dom-if" if="{{!vertex.id.length}}"><span class="normal-font">{{vertex.vocable}}</span></template></template><script>'use strict';

require(['backbone', 'pdgconst'], function (Backbone, Const) {
    Polymer({
        is: "rlf-vertex-xs",
        properties: {
            graph: Object,
            model: Object,
            lnid: String,
            form: { type: String, value: "" },
            css: String,

            complete: String,
            usagenote: Boolean

        },
        observers: ["observe_lnid(graph, lnid, form)", "observe(graph, model)"],

        created: function created() {

            var listener = {};
            _.extend(listener, Backbone.Events);
            this._listener = listener;
        },

        detached: function detached() {
            this._listener.stopListening();
        },

        observe_lnid: function observe_lnid(graph, lnid, form) {

            if (!graph || !lnid) return;
            if (lnid) {
                var _this = this;
                var vertex = this.graph.vs.filter(function (e) {
                    return e.properties.get('rlfid') == lnid;
                });

                if (vertex.length) {
                    this.set('model', vertex[0]);
                } else {
                    $.ajax({
                        url: "../complete/id/" + lnid,
                        success: function success(r) {
                            var complete = r.results.response.complete;
                            if (complete.length) {
                                var model = complete[0];
                                model.vocable = model.name;
                                model.id = model.uuid;
                                _this.model = model;
                            }
                        }
                    });
                }
            }
        },

        observe: function observe(graph, model) {
            var _this2 = this;

            this._listener.stopListening();

            if (this.model && this.ismodel()) {
                this._listener.listenTo(this.model, 'change', function () {
                    _this2.compute_properties();
                });
            }

            //if(this.model && this.model.graph){
            //this._listener.listenTo(this.model.graph.vs, 'add', (v) => {
            //if (this.model && v.properties.get('rlfid') == this.model.id) {
            //this._listener.stopListening();
            //this.model = v;
            //return;
            //}
            //});
            //}
            if (model && !model.graph) {
                this._listener.listenTo(this.graph.vs, 'add', function (v) {
                    if (model) {
                        var match = v.id == model.id || v.id == model.uuid;
                        if (match) _this2.set("model", v);
                    }
                });
            }

            this.compute_properties();
        },

        labelOrItem: function labelOrItem(vertex, form) {
            return vertex.id && !form.length;
        },

        ismodel: function ismodel() {
            var _ismodel = this.model.properties != null && this.model.id != null;
            return _ismodel;
        },

        compute_properties: function compute_properties() {
            var model = this.model;
            var vertex = null;

            if (!model) return;

            var keys = ['id', 'prefix', 'num', 'vocable', 'subscript', 'superscript'];

            if (model.properties) {
                if (model.id) {
                    vertex = keys.map(function (e) {
                        return [e, model.properties.get(e)];
                    });
                } else {
                    vertex = keys.map(function (e) {
                        return [e, model.properties[e]];
                    });
                }
            }

            if (!vertex && model.vocable) {
                vertex = keys.map(function (e) {
                    return [e, model[e]];
                });
            }

            vertex = _.object(vertex);
            vertex.fontcolor = "color:rgb(" + (this.ismodel() ? model.color : [0, 0, 0]) + ")";
            vertex.usagenote = this.usagenote && model.gc && "usagenote" in model.gc ? model.gc.usagenote.join(" ") : null;
            vertex.icon = this.ismodel();

            this.vertex = vertex;
        },

        mouseout: function mouseout(event) {
            this.do_action("mouseout", event, this.model);
        },
        mouseover: function mouseover(event) {
            this.do_action("intersect", event, this.model);
        },

        mouseclicked: function mouseclicked(event) {
            var ismodel = this.model.properties != null && this.model.id != null;
            this.do_action(ismodel ? "select" : "add", event, this.model);
        },

        do_action: function do_action(action, event, model) {

            if (!model) return;

            var ismodel = this.ismodel();

            if (action == 'add') {
                if (model.uuid) {
                    Backbone.trigger('engine:additive_nodes', [model.uuid]);
                } else {
                    $.ajax({
                        url: "../complete/id/" + model.id,
                        success: function success(r) {
                            var complete = r.results.response.complete;
                            if (complete.length) {
                                Backbone.trigger('engine:additive_nodes', [complete[0].uuid]);
                            }
                        }
                    });
                }
            } else if (action == 'mouseout') {
                if (ismodel) Backbone.trigger('vertex:mouseout', model, event);
            } else if (action == 'intersect') {
                if (ismodel) Backbone.trigger('vertex:mouseover', model, event);
            } else if (action == 'select') {
                if (ismodel) Backbone.trigger('select_node', model);
            } else if (action == 'explore') {
                if (ismodel) {
                    var params = { graph: this.model.graph.id, query: this.model.id };
                    Backbone.trigger('engine:explore', params);
                }
            } else if (action == 'expand') {
                var params = { graph: this.model.graph.id, expand: [this.model.id], weights: [] };
                Backbone.trigger('engine:expand_prox', params);
            }
        }

    });
});</script></dom-module><dom-module id="rlf-vertex-gc"><style>.vertex-gc { margin-left: 15pt; }
span:after { content: " "; }
</style><template><div class="vertex-gc">     <template is="dom-repeat" items="[[gc.usagenote]]"><span class="usage">{{item}}</span><br/></template><template is="dom-if" if="{{!gc.locution}}"><span class="pos">{{gc.pos.name}}</span><br/></template><template is="dom-if" if="{{gc.locution}}"><rlf-vertex-gc-locution graph="{{graph}}" model="{{model}}"></rlf-vertex-gc-locution><br/></template><template is="dom-repeat" items="[[gc.othergc]]"><span class="othergc">{{item}}</span><br/></template></div></template><script>'use strict';

require(['backbone', 'underscore', 'jquery', 'pdgconst'], function (Backbone, _, $, Const) {
  Polymer({
    is: "rlf-vertex-gc",
    properties: {
      graph: Object,
      model: Object,
      gc: Array
    },
    observers: ['observe(graph, model)'],

    observe: function observe(graph, model) {

      this.gc = model ? JSON.parse(model.properties.get('gc')) : {};
    }
  });
});</script></dom-module><dom-module id="rlf-vertex-gc-locution"><style>.gc.grey {
    color: grey;
}

span:after { content: " "; }
</style><template><template is="dom-if" if="[[tokens]]"><span>{{gc.locution.name}}</span><template is="dom-if" if="[[locution]]"><span>[</span><template is="dom-repeat" items="[[tokens]]" as="tk"><template is="dom-if" if="{{tk.model}}"><rlf-vertex-xs graph="{{graph}}" model="{{tk.model}}"></rlf-vertex-xs></template><template is="dom-if" if="{{!tk.model}}"><rlf-vertex-xs graph="{{graph}}" model="{{tk}}"></rlf-vertex-xs></template><template is="dom-if" if="{{ hasmore_token(tokens, index) }}"><span class="plus">&nbsp;+ </span></template></template><span>&nbsp]</span></template></template></template><script>'use strict';

require(['backbone', 'underscore', 'jquery', 'pdgconst'], function (Backbone, _, $, Const) {
    Polymer({
        is: "rlf-vertex-gc-locution",
        properties: {
            graph: Object,
            model: Object,
            tokens: Array
        },

        observers: ['observe(graph, model)'],

        observe: function observe(graph, model) {
            var self = this;
            this.tokens = null;
            this.locution = false;

            if (!graph || !model) return;
            // vertex as graph model
            var vs = graph.vs;
            var gc = model.graph ? JSON.parse(model.properties.get('gc')) : null;
            // vertex comes from neighbors .
            gc = !gc && model.properties.gc ? JSON.parse(model.properties.gc) : gc;

            if (gc.locution && gc.locution.tokens) {

                vs.on("add", function (v) {

                    gc.locution.tokens.forEach(function (e, i) {
                        if (v.properties.get('rlfid') == e.id) {
                            e.model = v;
                            var array = gc.locution.tokens.map(function (x) {
                                return x;
                            });
                            self.tokens = [];
                            self.tokens = array;
                            self.notifyPath('tokens.' + i + '.model');
                        }
                    });
                });

                gc.locution.tokens.forEach(function (e) {
                    if (e) {
                        var find = function find(v) {
                            return v.properties.get('id') == e.id;
                        };
                        var vertex = vs.find(find);
                        e.model = vertex;
                        e.graph = self.model.graph;
                    } else {
                        // TODO autre formz
                    }
                });

                this.tokens = gc.locution.tokens;
            }
            this.gc = gc;
        },
        hasmore_token: function hasmore_token(items, index) {
            return items ? index < items.length - 1 : false;
        }
    });
});</script></dom-module><dom-module id="rlf-vertex-ex"><style>/*example*/
div.example_quotation
{
/*	font-size: 12px;*/
    margin-left: 15pt;
    /*font-family: helvetica, verdana, arial, sans-serif;*/
}

div.example_quotation_disabled
{
    color: gray;
    font-size: 12px;
    margin-left: 15pt;
    /*font-family: helvetica, verdana, arial, sans-serif;*/
}

div.example_referencing
{
    font-size: 10px;
    margin-left: 15pt;
    margin-bottom: 5pt;
    font-family: 'Century Old Style Std', serif;
}

div.example_referencing_disabled
{
    color: gray;
    font-size: 10px;
    margin-left: 15pt;
    margin-bottom: 5pt;
    font-family: 'Century Old Style Std', serif;
}

span.example_source
{
    font-weight: bold;
}
span.example_source:after
{
    content : " ";
}

span.example_last_name
{
    text-transform: uppercase;
    /*font-variant: small-caps;*/
}
span.example_last_name:after
{
    content: " ";
}

span.example_first_name {}
span.example_first_name:after
{
    content: ", ";
}

span.example_title {
    font-style: italic;
}
span.example_title:after
{
    content: ", ";
}

span.example_date_day {}
span.example_date_day:after
{
    content: " ";
}

span.example_date_month {}

span.example_date_month:after { content: " ";}

span.example_date_year {}
span.example_date_year:after { content: ", "; }
span.example_date_location {}
span.example_date_location:after { content: " "; }

span.occurrence
{
    color: green;
    font-weight: bold;
}
</style><template><template is="dom-repeat" items="[[examples]]" as="example"><div class="example_quotation"><span inner-h-t-m-l="{{example.defhtml}}" class="defhtml"> </span></div><div class="example_referencing"><span class="example_source">{{ example.source }}</span><template is="dom-repeat" items="[[example.authors]]"><template is="dom-if" if="{{item.first_name}}"><span class="example_last_name">{{item.first_name}}</span></template><template is="dom-if" if="{{item.last_name}}"><span class="example_first_name">{{item.last_name}}</span></template></template><template is="dom-if" if="{{example.title}}"><span class="example_title">{{example.title}}</span></template><template is="dom-if" if="{{example.date_day}}"><span class="example_date_day">{{example.date_day}}</span></template><template is="dom-if" if="{{example.date_month}}"><span class="example_date_month">{{example.date_month}}</span></template><template is="dom-if" if="{{example.date_year}}"><span class="example_date_year">{{example.date_year}}</span></template><span class="example_location">{{ example.location }}</span></div></template></template><script>'use strict';

require(['backbone', 'underscore', 'jquery', 'pdgconst'], function (Backbone, _, $, Const) {
    Polymer({
        is: "rlf-vertex-ex",
        properties: {
            model: {
                type: Object,
                observer: 'observe'
            },
            examples: Object
        },

        observe: function observe(model) {
            if (!model) return;
            var months = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre'];

            var examples = JSON.parse(model.properties.get('examples'));

            examples.forEach(function (e) {
                var text = e.text;
                var date = months[e['date_month'] - 1];
                var pos = 0;
                var occurrences = [];
                e['occurrences'].forEach(function (oc) {
                    occurrences.push({ text: text.slice(pos, oc.first - 1), occurrence: false });
                    var t = "<span class='occurrence'>" + text.slice(oc.first - 1, oc.last) + "</span>";
                    occurrences.push({ text: t, occurrence: true });
                    pos = oc.last;
                });
                occurrences.push({ text: text.slice(pos), occurrence: false });

                if (occurrences.length) {
                    var n = occurrences.length - 1;
                    occurrences[0].text = occurrences[0].text.substring(15);
                    occurrences[n].text = occurrences[n].text.substring(0, occurrences[n].text.length - 18);
                }
                e['splitted'] = occurrences.join(' ');
                e.defhtml = occurrences.map(function (e) {
                    return e.text;
                }).join(' ');
            });

            this.examples = examples;
            //this.$.defhtml.innerHTML = df.html ? ("<div class='ui hidden divider'></div>" + df.html) : "" ;
        }

    });
});</script></dom-module><dom-module id="rlf-vertex-lf"><style>#neighbourhood.item {
  margin-left: 15pt;
}
#neighbourhood.item tr {
  vertical-align: text-top;
  margin-left: 15pt;
}
.neighbor, .neighbors {
  display: inline;
}
.stdslf:after {
    //content: ': ';
}
.neighbor:after
{
  content: ' , ';
}

.neighbor:last-of-type:after
{
  content: '';
}
</style><template><div id="neighbourhood" class="item"><table><template is="dom-repeat" items="[[by_edgetypes]]" as="item"><template is="dom-if" if="{{ item.neighbors.length }}"><tr><td><rlf-edge-type model="{{item.edgetype}}" class="stdslf"></rlf-edge-type></td><td> <div class="neighbors"><template is="dom-repeat" items="[[item.neighbors]]" as="edge"><div class="neighbor"><template is="dom-if" if="{{edge.node.id}}"><rlf-vertex-xs graph="{{graph}}" model="{{edge.node}}" usagenote="usagenote"></rlf-vertex-xs></template><template is="dom-if" if="{{!edge.node.id}}"><rlf-vertex-xs graph="{{graph}}" model="{{edge.node}}"></rlf-vertex-xs></template><template is="dom-if" if="{{edge.model.properties.attributes.syntacticframe.length}}"><span class="target_synt_frame">[{{edge.model.properties.attributes.syntacticframe}}]</span></template><template is="dom-if" if="{{edge.model.properties.attributes.constraint.length}}"><span class="target_constraint">| {{edge.model.properties.attributes.constraint}}</span></template></div></template></div></td></tr></template></template></table></div></template></dom-module><s><template is="dom-repeat" items="{{lfs}}"><div class="pop">{{item.pop_name}}</div><div class="lexical_function"></div><template is="dom-if" if="{{item.prefix}}"><div class="nstdlfc">{{item.prefix}}</div><div class="stdslf"></div></template></template></s><script>'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

require(['backbone', 'underscore', 'jquery', 'pdgconst'], function (Backbone, _, $, Const) {
    Polymer({
        is: "rlf-vertex-lf",
        properties: {
            graph: Object,
            model: Object
        },
        observers: ['observe(graph, model)'],

        observe: function observe(graph, model) {
            var _this = this;

            //this.lfs = model ? Object.values(JSON.parse(model.properties.get('lfs'))) : []

            if (!this._listener) {

                this._listener = {};
                _.extend(this._listener, Backbone.Events);
            }

            this._listener.stopListening();

            if (!graph || !model) return;

            var fetch = function fetch() {

                var success = function success(data) {
                    _this._update_neighbors(data);
                };

                if (model.graph) model.fetch_neighbors(success);
            };

            this._listener.listenTo(this.model.graph.vs, 'add', function (m) {
                return fetch(m);
            });

            fetch(model);
        },

        usagenote: function usagenote(model) {
            return model.gc.usagenote;
        },

        _update_neighbors: function _update_neighbors(data) {

            if (this.model == null || this.model.graph == null) return;
            if (data == null || data.neighbors == null) return;

            var neighbors = data.neighbors;
            var nodetypes = _.chain(neighbors).map(function (d) {
                return d[2].nodetype;
            }).uniq().map(function (d) {
                return [d, []];
            }).object().value();

            var edgetypes = _.chain(neighbors).map(function (d) {
                return d[0].edgetype;
            }).uniq().map(function (d) {
                return [d, []];
            }).object().value();

            var graph = this.model.graph;
            var vs = this.model.graph.vs;
            var es = this.model.graph.es;

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = neighbors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = _slicedToArray(_step.value, 3);

                    var edge = _step$value[0];
                    var relation = _step$value[1];
                    var node = _step$value[2];

                    var _node = vs.get(node.uuid) ? vs.get(node.uuid) : node;
                    var _edge = es.get(edge.uuid) ? es.get(edge.uuid) : edge;

                    //or 'resize horizontal icon' the day we have undirected links
                    var direction_icon = relation == "IN" ? 'long arrow left icon' : 'long arrow right icon';

                    var edgetype = graph.edgetypes.get(edge.edgetype);
                    var nodetype = graph.nodetypes.get(node.nodetype);

                    if (relation == "OUT") {

                        nodetypes[nodetype.id].push({ 'edgetype': edgetype.name, // name
                            'model': _edge, // bb model or dict
                            'relation': relation, // str
                            'node': _node, //- bb model or dict
                            'icon': direction_icon
                        });

                        edgetypes[edgetype.id].push({ 'edgetype': edgetype.name, //name
                            'model': _edge, // bb model or dict
                            'relation': relation, // str
                            'node': _node, //- bb model or dict
                            'icon': direction_icon
                        });
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator['return']) {
                        _iterator['return']();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.by_nodetypes = _.chain(nodetypes).pairs().sortBy(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 2);

                var k = _ref2[0];
                var e = _ref2[1];
                return e.length;
            }).map(function (_ref3) {
                var _ref32 = _slicedToArray(_ref3, 2);

                var k = _ref32[0];
                var e = _ref32[1];
                return {
                    nodetype: graph.nodetypes.get(k),
                    neighbors: e
                };
            }).value();

            var edgetype_filter = function edgetype_filter(e) {
                return true;
            };
            edgetype_filter = function (e) {
                return e.family == 'LexicalFunction';
            };

            var sort_neighbors = function sort_neighbors(a, b) {
                var l = function l(e) {
                    return parseInt(e.model.properties.position);
                };
                return l(a) - l(b);
            };

            var map_position = {
                "Co-polysemy": 1,
                "DefinitionalInclusion": 2,
                "LexicalFunction": 3,
                "FormalInclusion": 4
            };

            this.by_edgetypes = _.chain(edgetypes).pairs().sortBy(function (_ref4) {
                var _ref42 = _slicedToArray(_ref4, 2);

                var k = _ref42[0];
                var e = _ref42[1];
                return e.length;
            }).reverse().map(function (_ref5) {
                var _ref52 = _slicedToArray(_ref5, 2);

                var k = _ref52[0];
                var e = _ref52[1];

                var family = graph.edgetypes.get(k).parse_label()['family'];
                return {
                    uuid: k,
                    edgetype: graph.edgetypes.get(k),
                    family: family,
                    neighbors: e.sort(sort_neighbors),
                    position: map_position[family]
                };
            }).filter(edgetype_filter).sort(function (a, b) {
                return a.edgetype.type_attributes.order - b.edgetype.type_attributes.order;
            }).value();
        }

    });
});</script><dom-module id="rlf-vertex-df"><style>.definiendum {
    margin-left: 15pt;
    font-weight: normal;
    margin-left: 15pt;
    margin-bottom: 1pt;
    text-align: left;
    color: black;
}
.label {
    font-size:17px;
    font-family:courier;
}
p {
    margin : 0px;
}

.vocable {
    color: black;
    font-weight: bold;
}

#
</style><template><template is="dom-if" if="{{df.label_form}}"><div class="definiendum"><div class="label">{{df.label_form.name}}</div><template is="dom-if" if="{{df.left_pf_form || df.right_pf_form }}"><div class="pf"><span>{{left_pf_form}}</span><span class="vocable">{{model.properties.attributes.prefix}} {{tildevalue}}</span><span>{{right_pf_form}}</span></div></template></div></template><div class="definiendum"><div id="defhtml"></div></div><template is="dom-if" if="{{df.definiens}}"><div class="definiens">{{df.definiens}}</div></template></template><script>'use strict';

require(['backbone', 'underscore', 'jquery', 'pdgconst'], function (Backbone, _, $, Const) {
    Polymer({
        is: "rlf-vertex-df",
        properties: {
            graph: Object,
            model: Object,
            df: Object,
            right_pf_form: String,
            left_pf_form: String,
            tildevalue: String
        },
        observers: ['observe(graph, model)'],

        observe: function observe(graph, model) {

            if (!graph || !model) return;

            var df = JSON.parse(model.properties.get('df'));
            if (df.label_form == '') df.label_form = null;

            var left_pf_form = "",
                right_pf_form = "";

            if (df.propform) {
                left_pf_form = df.propform.substring(0, df.propform.indexOf('~'));
                df.actants.forEach(function (e) {
                    left_pf_form = left_pf_form.split(e[0]).join(e[1]);
                });
                right_pf_form = df.propform.substring(df.propform.indexOf('~') + 1);
                df.actants.forEach(function (e) {
                    right_pf_form = right_pf_form.split(e[0]).join(e[1]);
                });
                this.tildevalue = df.tildevalue == "" ? df.form : df.tildevalue;
            }
            // def html
            if (df.html) df.actants.forEach(function (e) {
                df.html = df.html.split(e[0]).join(e[1]);
            });

            this.df = df;
            this.left_pf_form = left_pf_form;
            this.right_pf_form = right_pf_form;

            this.$.defhtml.innerHTML = df.html && df.html.length ? "<div class=''>=</div>" + df.html : "";

            $("a", this).each(function (i, a) {
                var href = a.href;
                var form = a.text;
                var rlfid = href.substring(href.lastIndexOf('/') + 1);
                var xs = document.createElement("rlf-vertex-xs");
                a.replaceWith(xs);
                xs.asLabel = true;
                xs.set('form', form);
                xs.set('lnid', rlfid);
                xs.set('graph', graph);
                //xs.model = { id : rlfid };
            });
        }

    });
});</script></dom-module><dom-module id="rlf-vertex-loc"><style></style><template><template is="dom-if" if="{{ locutions.length }}"><template is="dom-repeat" items="[[locutions]]"><rlf-vertex-xs graph="{{graph}}" model="{{item}}" css="ui label"></rlf-vertex-xs><span> </span><rlf-vertex-gc-locution graph="{{graph}}" model="{{item}}"></rlf-vertex-gc-locution><br/></template></template></template><script>'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

require(['backbone', 'underscore', 'jquery', 'pdgconst'], function (Backbone, _, $, Const) {

  Polymer({
    is: "rlf-vertex-loc",
    properties: {
      graph: Object,
      model: {
        type: Object
      },
      lang: String,
      locutions: Array

    },

    observers: ['observe(graph, model)'],

    observe: function observe(graph, model, lang) {
      var _this = this;

      if (model == null) return;
      if (lang == null) this.lang = 'fr';

      var vs = graph.vs;
      var es = graph.es;

      var locutions = [];

      model.fetch_neighbors(function (data) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {

          for (var _iterator = data.neighbors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _slicedToArray(_step.value, 3);

            var edge = _step$value[0];
            var relation = _step$value[1];
            var node = _step$value[2];

            var _node = vs.get(node.uuid) ? vs.get(node.uuid) : node;
            var _edge = es.get(edge.uuid) ? es.get(edge.uuid) : edge;
            var et = graph.get_edge_type(_edge.edgetype);
            if (et.name == "FormalInclusion" && relation == "OUT") locutions.push(_node);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        _this.locutions = locutions;
      });
    }

  });
});</script></dom-module><dom-module id="rlf-vertex-card"><style>.rlf {
    text-align:left;
    padding:2px;
}

.rlf a {
    cursor:pointer;
}
</style><template><template is="dom-if" if="{{model}}">           <div class="rlf"><div class="ui message"><h2>   <rlf-vertex-xs graph="{{graph}}" model="{{model}}" css="" on-click="explore"></rlf-vertex-xs><div class="sub header"><template is="dom-if" if="{{debug}}"><a href="#expand" on-click="expand" class="ui label">+10 </a><a href="{{ geturl(model) }}/neighbors" target="_blank" class="ui label">neighbors</a><a href="/{{lang}}/id/{{ model.properties.attributes.rlfid }}" target="_blank" class="ui label">{{ model.properties.attributes.rlfid }} </a><a href="{{ geturl(model) }}" target="_blank" class="ui label">{{ short(model.id) }}</a></template></div></h2></div><h4>[{{i18n('GC')}}]</h4><rlf-vertex-gc graph="{{graph}}" model="{{model}}" complete="{{complete}}"></rlf-vertex-gc><div class="ui divider"></div><h4>[{{i18n('DF')}}]</h4><rlf-vertex-df graph="{{graph}}" model="{{model}}"></rlf-vertex-df><div class="ui divider"> </div><h4>[{{i18n('LF')}}]</h4><rlf-vertex-lf graph="{{graph}}" model="{{model}}" complete="{{complete}}"></rlf-vertex-lf><div class="ui divider"> </div><h4>[{{i18n('EX')}}]</h4><rlf-vertex-ex graph="{{graph}}" model="{{model}}"></rlf-vertex-ex><div class="ui divider"></div><h4>[{{i18n('PH')}}]</h4><rlf-vertex-loc graph="{{graph}}" model="{{model}}"></rlf-vertex-loc><div class="ui divider"></div></div></template></template><script>   'use strict';

require(['backbone', 'underscore', 'jquery', 'pdgconst'], function (Backbone, _, $, Const) {
  var I18N = {
    'fr': {

      // dictonnary
      'GC': 'CG',
      'DF': 'DF',
      'LF': 'FL',
      'EX': 'EX',
      'PH': 'PH'
    },
    'en': {

      // dictonnary
      'GC': 'GC',
      'DF': 'DF',
      'LF': 'LF',
      'EX': 'EX',
      'PH': 'PH'

    }

  };

  Polymer({
    is: "rlf-vertex-card",
    properties: {
      graph: Object,
      lang: String,
      complete: String,
      debug: Boolean,
      model: {
        type: Object
      }
    },

    i18n: function i18n(key) {
      return I18N[this.lang][key];
    },
    geturl: function geturl() {
      return this.model ? this.model.url() : "";
    },

    expand: function expand() {
      var graph = this.model.graph;
      var params = { graph: graph.id, expand: [this.model.id], weights: [] };
      Backbone.trigger('engine:expand_prox', params);
    },

    explore: function explore() {
      Backbone.trigger('explore', this.model);
    },

    short: function short(uuid) {
      return !uuid ? null : uuid.substring(0, 6) + '...' + uuid.substring(uuid.length - 4);
    }

  });
});</script></dom-module>